
## 命名规范

1.  所有组件或者指令的选择器增加对应的前缀(Prefix) ，比如：  `thy-button`   、  `styx-table`  
1.  Input 参数统一增加对应的前缀 Input 参数统一增加对应的前缀，如   `thySize`  ​、  `styxType`  
1. 如果组件内部直接读取 content 中的 <ng-template #name></ng-template>， name 不需要加前缀
1. 组件模块名添加前缀，如   `ThyButtonModule`  
1. 所有的 Output 参数命名把名词放在前面，动词或者过去分词放后面，比如   `thyPageChange`  、  `thyOptionSelect`  ​, 如果此组件是 NG_VALUE_ACCESSOR   `ngModel`   和   `ngModelChange`  ​无需加前缀
1. 所有的 Output 参数命名禁止使用 On，比如   `onPageChange`     `thyOnPageChange`  ​，由于之前写的组件都是带有 On 的，对于新组件或者新参数，严格遵守，旧组件参数逐渐替换
1. 是否存在分割线统一使用 divided，比如   `thyDivided`  ​
1. 是否存在边框统一使用 bordered，比如   `thyBordered`  




## 结构

每个组件模块独立一个文件夹，一个组件模块会包含 一个或者多个组件。

比如   `button`  ​、  `badge`  、  `avatar`  、  `layout`  ​...



## 约定

在开发过程中，我们会遇到一些特定场景，针对这些场景的代码编程我们遵守如下约定：

### 场景一：   **内部属性命名**

针对  `set`  、  `get`   的内部属性  **取名：，变量名统一使用 **  `**innerXxx**`  ，如

```
private innerColor: ThyColor;

set color(value: ThyColor) {
	this.alpha = Math.round(value.rgba.alpha * 100);
	this.innerColor = value;
}

get color() {
	return this.innerColor;
}
```



### 场景二：boolean 类型的输入参数增加修饰符

对于输入类型是   `boolean`   类型的参数，统一增加    `@InputBoolean()`  修饰符。

```
@Input() @InputBoolean() styxSelectCustomizable: boolean;
```



### 场景三：返回 Observable 的输入函数命名

对于组件中返回值为   `Observable`   的输入函数，在本身的名称后增加   `Action`  。

```
@Input() styxCreateAction: (property: PropertyInfo) => Observable>;
@Input() styxUpdateAction: (property: PropertyInfo) => Observable>;
```



## 文档

组件的文档对于组件库来说至关重要，高质量的文档可以提高使用者的学习成本和开发效率，对于如何写好组件库文档，我们一直在摸索，以下是定义的文档规范。

组件文档包含：概览、示例和 API，基本的目录结构如下，  `doc`  ​ 目录存放的是组件概览，  `examples`  ​  目录存放的是使用示例， API 文档通过在组件中添加注释的方式自动生成。

```
├── button
│   ├── button.component.ts
│   ├── button.module.ts
│   ├── doc
│   │   ├── en-us.md
│   │   └── zh-cn.md
│   ├── examples
│   │   ├── advance
│   │   │   ├── advance.component.html
│   │   │   ├── advance.component.scss
│   │   │   └── advance.component.ts
│   │   ├── basic
│   │   │   ├── basic.component.html
│   │   │   ├── basic.component.scss
│   │   │   ├── basic.component.ts
│   │   │   └── index.md
│   │   └── module.ts
│   ├── index.ts
```



### 概览

至少包含以下几项：

- 何时使用：描述组件使用场景
- 模块导入：单独使用该组件或者服务时，如何引用模块
- 使用：使用  `<examples/>`  展示   **examples**   目录下的所有示例。


除此之外，还可以包含令牌配置、默认配置信息、组件说明、导出的工具类方法等。

以下是最简单的概览示例：

```
---
category: layout
title: Card
subtitle: 卡片
description: 通用的卡片组件。
order: 20
---

<alert>通用的卡片组件。</alert>

## 何时使用
最基础的卡片组件，是一个内容容器，用于文本、照片和单个主题上下文的操作，同类信息聚合形成区块。

## 模块导入
```ts
import { ThyCardModule } from "tethys/card";
```

<examples />
```



### 示例

原则：简单直接，复制代码即可使用，按照场景划分示例类别。通用的组件一般会包含以下几种类型的示例：  **基本使用、大小、类型、自定义**  。当然每个组件都有其特殊性，但是基本原则类似。

- 基本使用示例：展示如何最简单的使用该组件，通常是该组件最经常使用的方式。
- 按照  **场景 / API**   划分示例：如果是参数是类似大小、主题这种可供选择的类型，并且示例较为简单，建议在一个示例中添加多种使用方式，比如大小分为：  `sm`  ​   `md`  ​   `lg`  ​ ，我们可以直接放三种大小的示例；但是如果示例内容比较复杂，也可以选择通过动态参数的方式来编写示例。


```
<button thySize="sm">Small</button>
<button thySize="md">Medium</button>
<button thySize="lg">Large</button>
```

对于示例的顺序，基本使用组件排在最前，在该示例文件夹中添加 index.md。指定 order。如下:
其他示例按照使用频率、优先级等排序。

```
---
title: Basic
order: 10
---
```



### API

通过在组件中添加注释的方式生成文档：

```
/**
 * thyDropdown 触发下拉菜单指令
 * @name thyDropdown （备注：这里的 name 代表的是使用组件时的真实名称，必须添加）
 */
@Directive({
    selector: `[thyDropdown]`,
    host: {
        class: 'thy-dropdown'
    }
})
export class ThyDropdownDirective implements OnInit {
    /**
     * 弹出菜单后的当前触发元素的激活样式类
     */
   @Input() thyActiveClass: string = 'thy-dropdown-origin-active';
  
    /**
     * 输入框大小
     * @type 'xs' | 'sm' | 'md' | 'default' | 'lg'
     * @default default
     */
    @Input() thySize: ThyInputSize;
}
```



## 测试

组件库对于测试的要求如下：

1. 单元测试文件以   `.spec.ts`  * *  结尾
1. 如果是已有的组件，涉及到 API 的新增 / 修改 / 缺陷修复等情况，需要补充单元测试
1. 新增的组件必须补充单元测试，原则上单元测试需要覆盖组件每一个 API 的功能




